#include "des.h"

// Перестановка PC1
ulong64 pc1(ulong64 v);
// Перестановка PC2
ulong64 pc2(ulong64 v);
// Начальная перестановка IP
ulong64 ip(ulong64 v);
// Конечная перестановка IP-1
ulong64 rip(ulong64 v);
// Функция расширения E
ulong64 ep(ulong v);
// Применение S-блоками
ulong s_matrix(ulong64 v);
// Перестановка Р
ulong p(ulong v);
// Функция фейстеля
ulong64 fk(ulong64 v, ulong64 key);

/****************************************************************************
 * На рисунке приведена обобщенная структурная схема алгоритма шифрования DES
 *                            +----------------+
 *                            ¦Открытый текст A¦
 *                            ¦   (64 бита)    ¦
 *                            +----------------+
 *                                    ¦
 *                                    ¦
 *                         +----------------------+
 *                         ¦Начальная перестановка¦
 *                         ¦         IP           ¦
 *                         +----------------------+
 *                                    ¦
 *              +------------------<----->--------------------+
 *              ¦                                             ¦
 *        +------------+                               +------------+
 *        ¦L0 (32 бита)¦                               ¦R0 (32 бита)¦
 *        +------------+                               +------------+
 *              ¦                                           ¦
 *              V                      +-----------<--------¦
 *              ¦                 +--------+                ¦
 *             (+)--------<------¦f(R0,K1)+-------<--------+---------- K1
 *              ¦                 +--------+                ¦
 *              ¦                                           ¦
 *              +---------------------->--------------------+-+
 *                                                          ¦ ¦
 *                                                          ¦ ¦
 *              +----------------------------------<--------+ ¦
 *              ¦                                             ¦
 *        +------------+                               +------------+
 *        ¦L1 (32 бита)¦                               ¦R1 (32 бита)¦
 *        +------------+                               +------------+
 *              ¦                                           ¦
 *              V                      +-----------<--------¦
 *              ¦                 +--------+                ¦
 *             (+)--------<------¦f(R1,K2)+-------<--------+---------- K2
 *              ¦                 +--------+                ¦
 *              ¦                                           ¦
 *              +---------------------->--------------------+-+
 *                                                          ¦ ¦
 *                                                          ¦ ¦
 *              +----------------------------------<--------+ ¦
 *              ¦                                             ¦
 *        +------------+                               +------------+
 *        ¦L2 (32 бита)¦                               ¦R2 (32 бита)¦
 *        +------------+                               +------------+
 * 
 *            ..................................................
 * 
 *              ¦                                             ¦
 *        +------------+                               +------------+
 *        ¦L15(32 бита)¦                               ¦R15(32 бита)¦
 *        +------------+                               +------------+
 *              ¦                                           ¦
 *              V                      +-----------<--------¦
 *              ¦                 +----------+              ¦
 *             (+)--------<------¦f(R15,K16)+-----<--------+---------- K16
 *              ¦                 +----------+              ¦
 *              ¦                                           ¦
 *              +---------------------->--------------------+-+
 *                                                          ¦ ¦
 *                                                          ¦ ¦
 *              +----------------------------------<--------+ ¦
 *              ¦                                             ¦
 *        +------------+                               +------------+
 *        ¦L16(32 бита)¦                               ¦R16(32 бита)¦
 *        +------------+                               +------------+
 *              ¦                                           ¦
 *              +----------->----------------------<--------+
 *                                     V
 *                      +------------------------------+
 *                      ¦Конечная обратная перестановка¦
 *                      ¦               -1             ¦
 *                      ¦             IP               ¦
 *                      +------------------------------+
 *                                     ¦
 *                                     ¦
 *                               +-----------+
 *                               ¦Шифртекст C¦
 *                               ¦ (64 бита) ¦
 *                               +-----------+
 *  (+) - операция сложения по модулю 2
 *   ¦ --->---
 *   V           - направления передачи информации
 *   ¦ ---<---
 * 
 * Результатом шифрования 64-битного блока открытого текста A при помощи 
 * ключа K является 64-битный шифртекст C, что принято обозначать равенством 
 *                            C=DES(A,K)
 *****************************************************************************/
ulong64 des_encrypt_block(ulong64 src, ulong64 keys[16])
{
	ulong64	r = {0, 0};
	ulong t;

	// Начальная перестановка
	r = ip(src);

	// 16 раундов
    for (int i = 0; i < 16; i++)
    	r = fk(r, keys[i]);

	// swap
	t = r.h;
	r.h	= r.l;
	r.l = t;

	// Конечная перестановка
	r = rip(r);

	return r;
}

/****************************************************************************
 * Рассмотрим алгоритм дешифрования двоичных блоков, зашифрованных при 
 * помощи DES. Этот алгоритм, обозначаемый через DES-1, достаточно очевиден: 
 * достаточно "прогнать" DES с тем же ключом в обратном направлении. 
 * При этом:
 *                       Ri-1 = Li
 *                Li-1 = Ri (+) f (Ri-1, Ki)
 ****************************************************************************/
ulong64 des_decrypt_block(ulong64 src, ulong64 keys[16])
{
	ulong64	r = {0, 0};
	ulong t;

	// Начальная перестановка
	r = ip(src);

	// 16 раундов
    for (int i = 15; i >= 0; i--)
    	r = fk(r, keys[i]);

	// swap
	t = r.h;
	r.h	= r.l;
	r.l = t;

	// Конечная перестановка
	r = rip(r);

	return r;
}

/****************************************************************************
 *						НАЧАЛЬНАЯ ПЕРЕСТАНОВКА IP	
 * Алгоритм DES функционирует следующим образом. Вначале выполняется так 
 * называемая начальная перестановка IP входного блока A (64 бит). 
 * Логика этой перестановки задается при помощи таблицы, где Ai обозначает 
 * i-й бит входного блока A, а IP(Ai) - номер позиции, в которую поступает 
 * i-й бит входного блока в результате перестановки.
 * +-----------------------------------------------------------------------
 * ¦IP(Ai)¦ 1 ¦ 2 ¦ 3 ¦ 4 ¦ 5 ¦ 6 ¦ 7 ¦ 8 ¦ 9 ¦ 10¦ 11¦ 12¦ 13¦ 14¦ 15¦ 16¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  Ai  ¦ 58¦ 50¦ 42¦ 34¦ 26¦ 18¦ 10¦ 2 ¦ 60¦ 52¦ 44¦ 36¦ 28¦ 20¦ 12¦ 4 ¦
 * +-----------------------------------------------------------------------
 * 
 * +-----------------------------------------------------------------------
 * ¦IP(Ai)¦ 17¦ 18¦ 19¦ 20¦ 21¦ 22¦ 23¦ 24¦ 25¦ 26¦ 27¦ 28¦ 29¦ 30¦ 31¦ 32¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  Ai  ¦ 62¦ 54¦ 46¦ 38¦ 30¦ 22¦ 14¦ 6 ¦ 64¦ 56¦ 48¦ 40¦ 32¦ 24¦ 16¦ 8 ¦
 * +-----------------------------------------------------------------------
 * 
 * +-----------------------------------------------------------------------
 * ¦IP(Ai)¦ 33¦ 34¦ 35¦ 36¦ 37¦ 38¦ 39¦ 40¦ 41¦ 42¦ 43¦ 44¦ 45¦ 46¦ 47¦ 48¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  Ai  ¦ 57¦ 49¦ 41¦ 33¦ 25¦ 17¦ 9 ¦ 1 ¦ 59¦ 51¦ 43¦ 35¦ 27¦ 19¦ 11¦ 3 ¦
 * +-----------------------------------------------------------------------
 * 
 * +----------------------------------------------------------------------+
 * ¦IP(Ai)¦ 49¦ 50¦ 51¦ 52¦ 53¦ 54¦ 55¦ 56¦ 57¦ 58¦ 59¦ 60¦ 61¦ 62¦ 63¦ 64¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦  Ai  ¦ 61¦ 53¦ 45¦ 37¦ 29¦ 21¦ 13¦ 5 ¦ 63¦ 55¦ 47¦ 39¦ 31¦ 23¦ 15¦ 7 ¦
 * +----------------------------------------------------------------------+
 *****************************************************************************/
ulong64 ip(ulong64 v)
{
	uchar p1[32] = 
	{
		57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11,  3, 
		61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15,  7
	};

	uchar p2[32] = 
	{
		56, 48, 40, 32, 24, 16,  8,  0, 58, 50, 42, 34, 26, 18, 10,  2, 
		60, 52, 44, 36, 28, 20, 12,  4, 62, 54, 46, 38, 30, 22, 14,  6
	};

	ulong64	r = {0, 0};
	ulong t;
	uchar s;

	// Младшие 32 бита
	for (int i = 31; i >= 0; i--)
	{
		s = p1[i];
		if (s > 31)
		{
			t = v.h;
			s -= 32;
		}
		else
		{
			t = v.l;
		}
		r.l |= ((t >> s) & 1) << i;
	}

	// Старшие 32 бита
	for (int i = 31; i >= 0; i--)
	{
		s = p2[i];
		if (s > 31)
		{
			t = v.h;
			s -= 32;
		}
		else
		{
			t = v.l;
		}
		r.h |= ((t >> s) & 1) << i;
	}
	return r;
}

/****************************************************************************
 *						ЗАВЕРШАЮЩАЯ ПЕРЕСТАНОВКА
 * После начальной перестановки выполняются 16 циклов шифрующих 
 * преобразований, после чего следует завершающая обратная перестановка, 
 * логика которой представлена в таблице, где Bi обозначает i-й бит 
 * шифртекста, полученного в результате выполнения упомянутых 16-ти циклов, 
 * а IP-1(Bi) - номер позиции, в которую поступает i-й бит указанного блока 
 * в результате перестановки. Блок C=IP-1(Bi) есть не что иное, как DES(A,K).
 *
 * +-----------------------------------------------------------------------
 * ¦IP(Bi)¦ 1 ¦ 2 ¦ 3 ¦ 4 ¦ 5 ¦ 6 ¦ 7 ¦ 8 ¦ 9 ¦ 10¦ 11¦ 12¦ 13¦ 14¦ 15¦ 16¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  Bi  ¦ 40¦ 8 ¦ 48¦ 16¦ 56¦ 24¦ 64¦ 32¦ 39¦ 7 ¦ 47¦ 15¦ 55¦ 23¦ 63¦ 31¦
 * +-----------------------------------------------------------------------
 * 
 * +-----------------------------------------------------------------------
 * ¦IP(Bi)¦ 17¦ 18¦ 19¦ 20¦ 21¦ 22¦ 23¦ 24¦ 25¦ 26¦ 27¦ 28¦ 29¦ 30¦ 31¦ 32¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  Bi  ¦ 38¦ 6 ¦ 46¦ 14¦ 54¦ 22¦ 62¦ 30¦ 37¦ 5 ¦ 45¦ 13¦ 53¦ 21¦ 61¦ 29¦
 * +-----------------------------------------------------------------------
 * 
 * +-----------------------------------------------------------------------
 * ¦IP(Bi)¦ 33¦ 34¦ 35¦ 36¦ 37¦ 38¦ 39¦ 40¦ 41¦ 42¦ 43¦ 44¦ 45¦ 46¦ 47¦ 48¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  Bi  ¦ 36¦ 4 ¦ 44¦ 12¦ 52¦ 20¦ 60¦ 28¦ 35¦ 3 ¦ 43¦ 11¦ 51¦ 19¦ 59¦ 27¦
 * +-----------------------------------------------------------------------
 * 
 * +----------------------------------------------------------------------+
 * ¦IP(Bi)¦ 49¦ 50¦ 51¦ 52¦ 53¦ 54¦ 55¦ 56¦ 57¦ 58¦ 59¦ 60¦ 61¦ 62¦ 63¦ 64¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦  Bi  ¦ 34¦ 2 ¦ 42¦ 10¦ 50¦ 18¦ 58¦ 26¦ 33¦ 1 ¦ 41¦ 9 ¦ 49¦ 17¦ 57¦ 25¦
 * +----------------------------------------------------------------------+
 *****************************************************************************/
ulong64 rip(ulong64 v)
{
	uchar p1[32] = 
	{
		39,  7, 47, 15, 55, 23, 63, 31, 38,  6, 46, 14, 54, 22, 62, 30, 
		37,  5, 45, 13, 53, 21, 61, 29, 36,  4, 44, 12, 52, 20, 60, 28
	};
	uchar p2[32] = 
	{
		35,  3, 43, 11, 51, 19, 59, 27, 34,  2, 42, 10, 50, 18, 58, 26, 
		33,  1, 41,  9, 49, 17, 57, 25, 32,  0, 40,  8, 48, 16, 56, 24
	};
	ulong64	r = {0, 0};
	ulong t;
	uchar s;

	for (int i = 31; i >= 0; i--)
	{
		t = v.l;
		s = p1[i];

		if (s > 31)
		{
			t = v.h;
			s -= 32;
		}
		r.l |= ((t >> s) & 1) << i;
	}
	for (int i = 31; i >= 0; i--)
	{
		t = v.l;
		s = p2[i];

		if (s > 31)
		{
			t = v.h;
			s -= 32;
		}
		r.h |= ((t >> s) & 1) << i;
	}
	return r;
}

/****************************************************************************
 * Перейдем к рассмотрению шифрующих преобразований, выполняемых внутри 
 * каждого из 16 циклов. Через Li-1 и  Ri-1 , i=1..16, обозначаются, 
 * соответственно, левые и правые 32-битные полублоки блока, являющегося 
 * входным для i-го цикла. При этом Li и Ri определяются по следующим правилам:
 *    Li  = Ri-1;
 *    Ri  = Li-1 (+) f(Ri-1, Ki),
 * где f(Ri-1, Ki) есть 32-битный полублок, а операция сложения по модулю 2 
 * выполняется над битами, находящихся в идентичных позициях обоих операндов.
 * Логика вычисления значений f(Ri-1, Ki) представлена в виде структурной 
 * схемы, приведенной на рис. 2.
 * 
 *                             +--------------+
 *                             ¦R    (32 бита)¦
 *                             ¦ i-1          ¦
 *                             +--------------+
 *                                    ¦
 *                                    ¦
 *                             +--------------+
 *                             ¦ Расширение E ¦
 *                             +--------------+
 *                                    ¦
 *                                    ¦
 *                             +--------------+
 *                             ¦ RE   (48 бит)¦
 *                             ¦   i-1        ¦
 *                             +--------------+
 *                                    ¦
 *                                   (+)---<---------- K  (48 бит)
 *                                    ¦                 i
 *                                    V
 *                                    ¦
 *   +------------------------------<--->------------------------------+
 *   ¦¦¦¦¦¦  ¦¦¦¦¦¦  ¦¦¦¦¦¦  ¦¦¦¦¦¦       ¦¦¦¦¦¦  ¦¦¦¦¦¦  ¦¦¦¦¦¦  ¦¦¦¦¦¦
 *   +----¦  +----¦  +----¦  +----¦       +----¦  +----¦  +----¦  +----¦
 *   ¦ S1 ¦  ¦ S2 ¦  ¦ S3 ¦  ¦ S4 ¦       ¦ S5 ¦  ¦ S6 ¦  ¦ S7 ¦  ¦ S8 ¦
 *   +----+  +----+  +----+  +----+       +----+  +----+  +----+  +----+
 *    ¦¦¦¦    ¦¦¦¦    ¦¦¦¦    ¦¦¦¦         ¦¦¦¦    ¦¦¦¦    ¦¦¦¦    ¦¦¦¦
 *    +----------------------------->---<-----------------------------+
 *                                    ¦
 *                                    V
 *                                    ¦
 *                                    ¦
 *                             +--------------+
 *                             ¦Перестановка P¦
 *                             ¦  (32 бита)   ¦
 *                             +--------------+
 *                                    ¦
 *                                    ¦
 *                             +--------------+
 *                             ¦  f(R   , K)  ¦
 *                             ¦     i-1      ¦
 *                             +--------------+
 *****************************************************************************/
ulong64 fk(ulong64 v, ulong64 key)
{
    // Результат
	ulong64	r = {0, 0};

    // Функция расширения
	r = ep(v.l);

	// XOR с ключом
	r.h ^= key.h;
	r.l ^= key.l;

	// Преобразование S
	r.l = s_matrix(r);

	// Перестановка Р
	r.l = p(r.l);

	// XOR с правой ч. источника
	r.l ^= v.h;

	// Правая и левая часть меняются местами
	r.h = v.l;

	return r;
}

/****************************************************************************
 *                    Функция расширения E
 * Вычисление начинается с так называемого расширения E, преобразующего 
 * 32-битный полублок в 48-битный вектор в соответствии с таблицей E, в 
 * которой i обозначает номер бита в 32-битном полублоке R, а E(i) - номер 
 * позиции в 48-битном векторе RE, куда поступает i-й бит полублока R. В 
 * случае, когда i-й бит "размножается" в две позиции, их номера указываются 
 * в соответствующей ячейке таблицы через запятую.
 * +----------------------------------------------------------------------------
 * ¦  i ¦  1 ¦ 2 ¦ 3 ¦ 4 ¦ 5 ¦ 6 ¦ 7 ¦  8  ¦  9  ¦10¦11¦ 12  ¦  13 ¦14¦15¦  16 ¦
 * +----+----+---+---+---+---+---+---+-----+-----+--+--+-----+-----+--+--+-----+
 * ¦E(i)¦2,48¦ 3 ¦ 4 ¦5,7¦6,8¦ 9 ¦ 10¦11,13¦12,14¦15¦16¦17,19¦18,20¦21¦22¦23,25¦
 * +----------------------------------------------------------------------------
 * 
 * +----------------------------------------------------------------------------+
 * ¦  i ¦  17 ¦18¦19¦  20 ¦  21 ¦22¦ 23¦  24 ¦  25 ¦26¦27¦ 28  ¦  29 ¦30¦31¦ 32 ¦
 * +----+-----+--+--+-----+-----+--+---+-----+-----+--+--+-----+-----+--+--+----¦
 * ¦E(i)¦24,26¦27¦28¦29,31¦30,32¦33¦ 34¦35,37¦36,38¦39¦40¦41,43¦42,44¦45¦46¦1,47¦
 * +----------------------------------------------------------------------------+
 *****************************************************************************/
ulong64 ep(ulong v)
{
	uchar p1[] = 
	{
		31,  0,  1,  2,  3,  4, 3,  4,  5,  6,  7,  8, 7,  8,  9, 10, 
		11, 12, 11, 12, 13, 14, 15, 16, 15, 16, 17, 18, 19, 20, 19, 20
	};
	uchar p2[] = 
	{ 
		21, 22, 23, 24, 23, 24, 25, 26, 27, 28, 27, 28, 29, 30, 31,  0
	};
	ulong64	r = {0, 0};

	for (int i = 31; i >= 0; i--)
		r.l |= ((v >> p1[i]) & 1) << i;

	for (int i = 15; i >= 0; i--)
		r.h |= ((v >> p2[i]) & 1) << i;

	return r;
}

/****************************************************************************
 * Полученные 48 бит гаммируются с 48-битным вектором Kj, логика 
 * формирования которого рассматривается ниже. Результат гаммирования 
 * разбивается на восемь 6-битовых векторов, поступающих на входы так 
 * называемых S-блоков, S1..S8. Каждый S-блок выдает 4-битовый вектор, 
 * причем взаимосвязь между входными и выходными данными определяется 
 * содержимым приводимых ниже таблиц и правилами их использования, 
 * существо которых состоит в следующем. Пусть b1..b6 - 6-битовый вектор, 
 * поступающий на вход некоторого S-блока Si. Образуем два десятичных числа 
 * k и l, двоичная запись первого из которых есть b1b6, а второго - b2b3b4b5. 
 * Например, применительно к вектору 000110B: k=0, l=3. Тогда результатом 
 * работы S-блока Si, соответствующим входу b1..b6, является 4-битовая 
 * двоичная запись десятичного числа, стоящего на пересечении k-й строки и 
 * l-го столбца i-й матрицы. Например, при поступлении вектора 000110B на вход 
 * блока S4 результатом будет 3D=0011B; результатом работы блока S6 при 
 * поступлении вектора 110001B, k=3, l=8, будет 11D=1011B.
 * +-----------------------------------------------------------------------+
 * ¦ i ¦ l ¦ 0 ¦ 1 ¦ 2 ¦ 3 ¦ 4 ¦ 5 ¦ 6 ¦ 7 ¦ 8 ¦ 9 ¦ 10¦ 11¦ 12¦ 13¦ 14¦ 15¦
 * ¦   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   ¦ k ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦
 * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   ¦ 0 ¦ 14¦ 4 ¦ 13¦ 1 ¦ 2 ¦ 15¦ 11¦ 8 ¦ 3 ¦ 10¦ 6 ¦ 12¦ 5 ¦ 9 ¦ 0 ¦ 7 ¦
 * ¦   ¦ 1 ¦ 0 ¦ 15¦ 7 ¦ 4 ¦ 14¦ 2 ¦ 13¦ 1 ¦ 10¦ 6 ¦ 12¦ 11¦ 9 ¦ 5 ¦ 3 ¦ 8 ¦
 * ¦S1 ¦ 2 ¦ 4 ¦ 1 ¦ 14¦ 8 ¦ 13¦ 6 ¦ 2 ¦ 11¦ 15¦ 12¦ 9 ¦ 7 ¦ 3 ¦ 10¦ 5 ¦ 0 ¦
 * ¦   ¦ 3 ¦ 15¦ 12¦ 8 ¦ 2 ¦ 4 ¦ 9 ¦ 1 ¦ 7 ¦ 5 ¦ 11¦ 3 ¦ 14¦ 10¦ 0 ¦ 6 ¦ 13¦
 * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   ¦ 0 ¦ 15¦ 1 ¦ 8 ¦ 14¦ 6 ¦ 11¦ 3 ¦ 4 ¦ 9 ¦ 7 ¦ 2 ¦ 13¦ 12¦ 0 ¦ 5 ¦ 10¦
 * ¦   ¦ 1 ¦ 3 ¦ 13¦ 4 ¦ 7 ¦ 15¦ 2 ¦ 8 ¦ 14¦ 12¦ 0 ¦ 1 ¦ 10¦ 6 ¦ 9 ¦ 11¦ 5 ¦
 * ¦S2 ¦ 2 ¦ 0 ¦ 14¦ 7 ¦ 11¦ 10¦ 4 ¦ 13¦ 1 ¦ 5 ¦ 8 ¦ 12¦ 6 ¦ 9 ¦ 3 ¦ 2 ¦ 15¦
 * ¦   ¦ 3 ¦ 13¦ 8 ¦ 10¦ 1 ¦ 3 ¦ 15¦ 4 ¦ 2 ¦ 11¦ 6 ¦ 7 ¦ 12¦ 0 ¦ 5 ¦ 14¦ 9 ¦
 * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   ¦ 0 ¦ 10¦ 0 ¦ 9 ¦ 14¦ 6 ¦ 3 ¦ 15¦ 5 ¦ 1 ¦ 13¦ 12¦ 7 ¦ 11¦ 4 ¦ 2 ¦ 8 ¦
 * ¦   ¦ 1 ¦ 13¦ 7 ¦ 0 ¦ 9 ¦ 3 ¦ 4 ¦ 6 ¦ 10¦ 2 ¦ 8 ¦ 5 ¦ 14¦ 12¦ 11¦ 15¦ 1 ¦
 * ¦S3 ¦ 2 ¦ 13¦ 6 ¦ 4 ¦ 9 ¦ 8 ¦ 15¦ 3 ¦ 0 ¦ 11¦ 1 ¦ 2 ¦ 12¦ 5 ¦ 10¦ 14¦ 7 ¦
 * ¦   ¦ 3 ¦ 1 ¦ 10¦ 13¦ 0 ¦ 6 ¦ 9 ¦ 8 ¦ 7 ¦ 4 ¦ 15¦ 14¦ 3 ¦ 11¦ 5 ¦ 2 ¦ 12¦
 * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   ¦ 0 ¦ 7 ¦ 13¦ 14¦ 3 ¦ 0 ¦ 6 ¦ 9 ¦ 10¦ 1 ¦ 2 ¦ 8 ¦ 5 ¦ 11¦ 12¦ 4 ¦ 15¦
 * ¦   ¦ 1 ¦ 13¦ 8 ¦ 11¦ 5 ¦ 6 ¦ 15¦ 0 ¦ 3 ¦ 4 ¦ 7 ¦ 2 ¦ 12¦ 1 ¦ 10¦ 14¦ 9 ¦
 * ¦S4 ¦ 2 ¦ 10¦ 6 ¦ 9 ¦ 0 ¦ 12¦ 11¦ 7 ¦ 13¦ 15¦ 1 ¦ 3 ¦ 14¦ 5 ¦ 2 ¦ 8 ¦ 4 ¦
 * ¦   ¦ 3 ¦ 3 ¦ 15¦ 0 ¦ 6 ¦ 10¦ 1 ¦ 13¦ 8 ¦ 9 ¦ 4 ¦ 5 ¦ 11¦ 12¦ 7 ¦ 2 ¦ 14¦
 * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   ¦ 0 ¦ 2 ¦ 12¦ 4 ¦ 1 ¦ 7 ¦ 10¦ 11¦ 6 ¦ 8 ¦ 5 ¦ 3 ¦ 15¦ 13¦ 0 ¦ 14¦ 9 ¦
 * ¦   ¦ 1 ¦ 14¦ 11¦ 2 ¦ 12¦ 4 ¦ 7 ¦ 13¦ 1 ¦ 5 ¦ 0 ¦ 15¦ 10¦ 3 ¦ 9 ¦ 8 ¦ 6 ¦
 * ¦S5 ¦ 2 ¦ 4 ¦ 2 ¦ 1 ¦ 11¦ 10¦ 13¦ 7 ¦ 8 ¦ 15¦ 9 ¦ 12¦ 5 ¦ 6 ¦ 3 ¦ 0 ¦ 14¦
 * ¦   ¦ 3 ¦ 11¦ 8 ¦ 12¦ 7 ¦ 1 ¦ 14¦ 2 ¦ 13¦ 6 ¦ 15¦ 0 ¦ 9 ¦ 10¦ 4 ¦ 5 ¦ 3 ¦
 * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   ¦ 0 ¦ 12¦ 1 ¦ 10¦ 15¦ 9 ¦ 2 ¦ 6 ¦ 8 ¦ 0 ¦ 13¦ 3 ¦ 4 ¦ 14¦ 7 ¦ 5 ¦ 11¦
 * ¦   ¦ 1 ¦ 10¦ 15¦ 4 ¦ 2 ¦ 7 ¦ 12¦ 9 ¦ 5 ¦ 6 ¦ 1 ¦ 13¦ 14¦ 0 ¦ 11¦ 3 ¦ 8 ¦
 * ¦S6 ¦ 2 ¦ 9 ¦ 14¦ 15¦ 5 ¦ 2 ¦ 8 ¦ 12¦ 3 ¦ 7 ¦ 0 ¦ 4 ¦ 10¦ 1 ¦ 13¦ 11¦ 6 ¦
 * ¦   ¦ 3 ¦ 4 ¦ 3 ¦ 2 ¦ 12¦ 9 ¦ 5 ¦ 15¦ 10¦ 11¦ 14¦ 1 ¦ 7 ¦ 6 ¦ 0 ¦ 8 ¦ 13¦
 * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   ¦ 0 ¦ 4 ¦ 11¦ 2 ¦ 14¦ 15¦ 0 ¦ 8 ¦ 13¦ 3 ¦ 12¦ 9 ¦ 7 ¦ 5 ¦ 10¦ 6 ¦ 1 ¦
 * ¦   ¦ 1 ¦ 13¦ 0 ¦ 11¦ 7 ¦ 4 ¦ 9 ¦ 1 ¦ 10¦ 14¦ 3 ¦ 5 ¦ 12¦ 2 ¦ 15¦ 8 ¦ 6 ¦
 * ¦S7 ¦ 2 ¦ 1 ¦ 4 ¦ 11¦ 13¦ 12¦ 3 ¦ 7 ¦ 14¦ 10¦ 15¦ 6 ¦ 8 ¦ 0 ¦ 5 ¦ 9 ¦ 2 ¦
 * ¦   ¦ 3 ¦ 6 ¦ 11¦ 13¦ 8 ¦ 1 ¦ 4 ¦ 10¦ 7 ¦ 9 ¦ 5 ¦ 0 ¦ 15¦ 14¦ 2 ¦ 3 ¦ 12¦
 * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   ¦ 0 ¦ 13¦ 2 ¦ 8 ¦ 4 ¦ 6 ¦ 15¦ 11¦ 1 ¦ 10¦ 9 ¦ 3 ¦ 14¦ 5 ¦ 0 ¦ 12¦ 7 ¦
 * ¦   ¦ 1 ¦ 1 ¦ 15¦ 13¦ 8 ¦ 10¦ 3 ¦ 7 ¦ 4 ¦ 12¦ 5 ¦ 6 ¦ 11¦ 0 ¦ 14¦ 9 ¦ 2 ¦
 * ¦S8 ¦ 2 ¦ 7 ¦ 11¦ 4 ¦ 1 ¦ 9 ¦ 12¦ 14¦ 2 ¦ 0 ¦ 6 ¦ 10¦ 13¦ 15¦ 13¦ 5 ¦ 8 ¦
 * ¦   ¦ 3 ¦ 2 ¦ 1 ¦ 14¦ 7 ¦ 4 ¦ 10¦ 8 ¦ 13¦ 5 ¦ 12¦ 9 ¦ 0 ¦ 3 ¦ 5 ¦ 5 ¦ 11¦
 * +-----------------------------------------------------------------------+
 *****************************************************************************/
ulong s_matrix(ulong64 v)
{
	static ulong s1[] = 
	{
		14 << 28,  4 << 28, 13 << 28,  1 << 28,  2 << 28, 15 << 28, 11 << 28,  8 << 28,  3 << 28, 10 << 28,  6 << 28, 12 << 28,  5 << 28,  9 << 28,  0 << 28,  7 << 28,
		0 << 28, 15 << 28,  7 << 28,  4 << 28, 14 << 28,  2 << 28, 13 << 28,  1 << 28, 10 << 28,  6 << 28, 12 << 28, 11 << 28,  9 << 28,  5 << 28,  3 << 28,  8 << 28,
		4 << 28,  1 << 28, 14 << 28,  8 << 28, 13 << 28,  6 << 28,  2 << 28, 11 << 28, 15 << 28, 12 << 28,  9 << 28,  7 << 28,  3 << 28, 10 << 28,  5 << 28,  0 << 28,
		15 << 28, 12 << 28,  8 << 28,  2 << 28,  4 << 28,  9 << 28,  1 << 28,  7 << 28,  5 << 28, 11 << 28,  3 << 28, 14 << 28, 10 << 28,  0 << 28,  6 << 28, 13 << 28
	};
	static ulong s2[] = 
	{
		15 << 24,  1 << 24,  8 << 24, 14 << 24,  6 << 24, 11 << 24,  3 << 24,  4 << 24,  9 << 24,  7 << 24,  2 << 24, 13 << 24, 12 << 24,  0 << 24,  5 << 24, 10 << 24,
		3 << 24, 13 << 24,  4 << 24,  7 << 24, 15 << 24,  2 << 24,  8 << 24, 14 << 24, 12 << 24,  0 << 24,  1 << 24, 10 << 24,  6 << 24,  9 << 24, 11 << 24,  5 << 24,
		0 << 24, 14 << 24,  7 << 24, 11 << 24, 10 << 24,  4 << 24, 13 << 24,  1 << 24,  5 << 24,  8 << 24, 12 << 24,  6 << 24,  9 << 24,  3 << 24,  2 << 24, 15 << 24,
		13 << 24,  8 << 24, 10 << 24,  1 << 24,  3 << 24, 15 << 24,  4 << 24,  2 << 24, 11 << 24,  6 << 24,  7 << 24, 12 << 24,  0 << 24,  5 << 24, 14 << 24,  9 << 24			
	};
	static ulong s3[] = 
	{
		10 << 20,  0 << 20,  9 << 20, 14 << 20,  6 << 20,  3 << 20, 15 << 20,  5 << 20,  1 << 20, 13 << 20, 12 << 20,  7 << 20, 11 << 20,  4 << 20,  2 << 20,  8 << 20,
		13 << 20,  7 << 20,  0 << 20,  9 << 20,  3 << 20,  4 << 20,  6 << 20, 10 << 20,  2 << 20,  8 << 20,  5 << 20, 14 << 20, 12 << 20, 11 << 20, 15 << 20,  1 << 20,
		13 << 20,  6 << 20,  4 << 20,  9 << 20,  8 << 20, 15 << 20,  3 << 20,  0 << 20, 11 << 20,  1 << 20,  2 << 20, 12 << 20,  5 << 20, 10 << 20, 14 << 20,  7 << 20,
		1 << 20, 10 << 20, 13 << 20,  0 << 20,  6 << 20,  9 << 20,  8 << 20,  7 << 20,  4 << 20, 15 << 20, 14 << 20,  3 << 20, 11 << 20,  5 << 20,  2 << 20, 12 << 20
	};
	static ulong s4[] = 
	{
		7 << 16, 13 << 16, 14 << 16,  3 << 16,  0 << 16,  6 << 16,  9 << 16, 10 << 16,  1 << 16,  2 << 16,  8 << 16,  5 << 16, 11 << 16, 12 << 16,  4 << 16, 15 << 16,
		13 << 16,  8 << 16, 11 << 16,  5 << 16,  6 << 16, 15 << 16,  0 << 16,  3 << 16,  4 << 16,  7 << 16,  2 << 16, 12 << 16,  1 << 16, 10 << 16, 14 << 16,  9 << 16,
		10 << 16,  6 << 16,  9 << 16,  0 << 16, 12 << 16, 11 << 16,  7 << 16, 13 << 16, 15 << 16,  1 << 16,  3 << 16, 14 << 16,  5 << 16,  2 << 16,  8 << 16,  4 << 16,
		3 << 16, 15 << 16,  0 << 16,  6 << 16, 10 << 16,  1 << 16, 13 << 16,  8 << 16,  9 << 16,  4 << 16,  5 << 16, 11 << 16, 12 << 16,  7 << 16,  2 << 16, 14 << 16
	};
	static ulong s5[] = 
	{
		2 << 12, 12 << 12,  4 << 12,  1 << 12,  7 << 12, 10 << 12, 11 << 12,  6 << 12,  8 << 12,  5 << 12,  3 << 12, 15 << 12, 13 << 12,  0 << 12, 14 << 12,  9 << 12,
		14 << 12, 11 << 12,  2 << 12, 12 << 12,  4 << 12,  7 << 12, 13 << 12,  1 << 12,  5 << 12,  0 << 12, 15 << 12, 10 << 12,  3 << 12,  9 << 12,  8 << 12,  6 << 12,
		4 << 12,  2 << 12,  1 << 12, 11 << 12, 10 << 12, 13 << 12,  7 << 12,  8 << 12, 15 << 12,  9 << 12, 12 << 12,  5 << 12,  6 << 12,  3 << 12,  0 << 12, 14 << 12,
		11 << 12,  8 << 12, 12 << 12,  7 << 12,  1 << 12, 14 << 12,  2 << 12, 13 << 12,  6 << 12, 15 << 12,  0 << 12,  9 << 12, 10 << 12,  4 << 12,  5 << 12,  3 << 12
	};
	static ulong s6[] = 
	{
		12 << 8,  1 << 8, 10 << 8, 15 << 8,  9 << 8,  2 << 8,  6 << 8,  8 << 8,  0 << 8, 13 << 8,  3 << 8,  4 << 8, 14 << 8,  7 << 8,  5 << 8, 11 << 8,
		10 << 8, 15 << 8,  4 << 8,  2 << 8,  7 << 8, 12 << 8,  9 << 8,  5 << 8,  6 << 8,  1 << 8, 13 << 8, 14 << 8,  0 << 8, 11 << 8,  3 << 8,  8 << 8,
		9 << 8, 14 << 8, 15 << 8,  5 << 8,  2 << 8,  8 << 8, 12 << 8,  3 << 8,  7 << 8,  0 << 8,  4 << 8, 10 << 8,  1 << 8, 13 << 8, 11 << 8,  6 << 8,
		4 << 8,  3 << 8,  2 << 8, 12 << 8,  9 << 8,  5 << 8, 15 << 8, 10 << 8, 11 << 8, 14 << 8,  1 << 8,  7 << 8,  6 << 8,  0 << 8,  8 << 8, 13 << 8
	};
	static ulong s7[] =
	{
		4 << 4, 11 << 4,  2 << 4, 14 << 4, 15 << 4,  0 << 4,  8 << 4, 13 << 4,  3 << 4, 12 << 4,  9 << 4,  7 << 4,  5 << 4, 10 << 4,  6 << 4,  1 << 4,
		13 << 4,  0 << 4, 11 << 4,  7 << 4,  4 << 4,  9 << 4,  1 << 4, 10 << 4, 14 << 4,  3 << 4,  5 << 4, 12 << 4,  2 << 4, 15 << 4,  8 << 4,  6 << 4,
		1 << 4,  4 << 4, 11 << 4, 13 << 4, 12 << 4,  3 << 4,  7 << 4, 14 << 4, 10 << 4, 15 << 4,  6 << 4,  8 << 4,  0 << 4,  5 << 4,  9 << 4,  2 << 4,
		6 << 4, 11 << 4, 13 << 4,  8 << 4,  1 << 4,  4 << 4, 10 << 4,  7 << 4,  9 << 4,  5 << 4,  0 << 4, 15 << 4, 14 << 4,  2 << 4,  3 << 4, 12 << 4
	};
	static ulong s8[] = 
	{
		13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
		1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
		7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
		2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11
	};

	v.h <<= 2;
	v.h |= (v.l >> 30);

	return
		s1[(((v.h >> 12) & 0x20) | ((v.h >>  8) & 0x10)) + ((v.h >> 13) & 0xF)] |
		s2[(((v.h >>  6) & 0x20) | ((v.h >>  2) & 0x10)) + ((v.h >>  7) & 0xF)] |
		s3[(((v.h      ) & 0x20) | ((v.h <<  4) & 0x10)) + ((v.h >>  1) & 0xF)] |
		s4[(((v.l >> 24) & 0x20) | ((v.l >> 20) & 0x10)) + ((v.l >> 25) & 0xF)] |
		s5[(((v.l >> 18) & 0x20) | ((v.l >> 14) & 0x10)) + ((v.l >> 19) & 0xF)] |
		s6[(((v.l >> 12) & 0x20) | ((v.l >>  8) & 0x10)) + ((v.l >> 13) & 0xF)] |
		s7[(((v.l >>  6) & 0x20) | ((v.l >>  2) & 0x10)) + ((v.l >>  7) & 0xF)] |
		s8[(((v.l      ) & 0x20) | ((v.l <<  4) & 0x10)) + ((v.l >>  1) & 0xF)];
}

/****************************************************************************
 * Восемь 4-битовых векторов, поступающих с выходов S-блоков, образуют 
 * 32-битовый полублок, который подвергается перестановке, определяемый 
 * таблицей P, в которой по аналогии с ранее приведенными таблицами, 
 * P(i) есть номер позиции, в которую попадает i-й бит входного полублока.
 * +-----------------------------------------------------------------------
 * ¦ P(i) ¦ 1 ¦ 2 ¦ 3 ¦ 4 ¦ 5 ¦ 6 ¦ 7 ¦ 8 ¦ 9 ¦ 10¦ 11¦ 12¦ 13¦ 14¦ 15¦ 16¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  i   ¦ 16¦ 7 ¦ 20¦ 21¦ 29¦ 12¦ 28¦ 17¦ 1 ¦ 15¦ 23¦ 26¦ 5 ¦ 18¦ 31¦ 10¦
 * +-----------------------------------------------------------------------
 * 
 * +----------------------------------------------------------------------+
 * ¦ P(i) ¦ 17¦ 18¦ 19¦ 20¦ 21¦ 22¦ 23¦ 24¦ 25¦ 26¦ 27¦ 28¦ 29¦ 30¦ 31¦ 32¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦  i   ¦ 2 ¦ 8 ¦ 24¦ 14¦ 32¦ 27¦ 3 ¦ 9 ¦ 19¦ 13¦ 30¦ 6 ¦ 22¦ 11¦ 4 ¦ 25¦
 * +----------------------------------------------------------------------+
 *****************************************************************************/
ulong p(ulong v)
{
	uchar p1[] = 
	{
		7,  28, 21, 10, 26,  2, 19, 13, 23, 29,  5,  0, 18,  8, 24, 30,
		22,  1, 14, 27,  6,  9, 17, 31, 15,  4, 20,  3, 11, 12, 25, 16
	};
	ulong r = 0;

	for (int i = 31; i >= 0; i--)
		r |= ((v >> p1[i]) & 1) << i;
	return r;
}

/****************************************************************************
 * Рассмотрим теперь логику формирования ключей Ki, i=1..16, используемых для 
 * гаммирования в ходе выполнения соответствующих циклов шифрования.
 * Исходный 64-битовый ключ K разбивается на восемь 8-битовых блоков. 
 * Восьмой бит каждого блока служит для контроля четности, который позволяет 
 * выявлять ошибки типа искажения нечетного числа битов (подобные ошибки 
 * могут возникнуть при хранении или непосредственно в процессе формирования 
 * ключей). При этом значение указанного восьмого бита представляет собой 
 * результат сложения по модулю 2 предшествующих семи битов. Контрольные биты 
 * в процессе формирования ключей не используются.
 * Обобщенная структурная схема алгоритма формирования ключей:
 *              +----------------+
 *              ¦Ключ K (64 бита)¦
 *              +----------------+
 *                      ¦
 *                      ¦
 *             +------------------+
 *             ¦Перестановка-выбор¦
 *             ¦       PC1        ¦
 *             +------------------+
 *                      ¦
 *                      ¦K0 (56 бит)
 *                      ¦
 *         +--------------------------+
 *         ¦ L0 (28 бит)              ¦ R0 (28 бит)
 * +---------------+          +---------------+
 * ¦Сдвиг влево LS1¦          ¦Сдвиг влево LS1¦
 * +---------------+          +---------------+
 *         ¦                          ¦
 *         +-----------------------------------------------------+
 *         ¦                          ¦                          ¦
 *         ¦                          +----------------+         ¦
 *         ¦ L1 (28 бит)              ¦ R1 (28 бит)    ¦         ¦
 * +---------------+          +---------------+    +------------------+
 * ¦Сдвиг влево LS2¦          ¦Сдвиг влево LS2¦    ¦Перестановка-выбор¦
 * +---------------+          +---------------+    ¦       PC2        ¦
 *         ¦                          ¦            +------------------+
 *         ¦                          ¦                     +-------------
 *         ¦ L2 (28 бит)              ¦ R2 (28 бит)           K1 (48 бит)
 *         +-----------------------------------------------------+
 *         ¦                          ¦                          ¦
 *         ¦                          +----------------+         ¦
 *         ¦                          ¦                ¦         ¦
 *                                                 +------------------+
 *                                                 ¦Перестановка-выбор¦
 *       .....                      .....          ¦       PC2        ¦
 *                                                 +------------------+
 *                                                          +-------------
 *                                                             K2 (48 бит)
 * 
 *         +-----------------------------------------------------+
 *                                    ¦                          ¦
 *                                    +----------------+         ¦
 *                                                     ¦         ¦
 *                                                 +------------------+
 *                                                 ¦Перестановка-выбор¦
 *                                                 ¦       PC2        ¦
 *                                                 +------------------+
 *                                                          +-------------
 *                                                               K16 (48 бит)
 * 
 *****************************************************************************/
void des_create_keys(ulong64 src, ulong64 key[16])
{
	uchar ss[] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};
	uchar s;
	ulong64 t;

	// Перестановка-выбор PC1
	t = pc1(src);

	for (int i = 0; i < 16; i++)
	{
		s = ss[i];

		t.l = (0x0FFFFFFF & (t.l << s)) | (t.l >> (28 - s));
		t.h = (0x0FFFFFFF & (t.h << s)) | (t.h >> (28 - s));

		// Перестановка-выбор PC2
		key[i] = pc2(t);
	}
}

/****************************************************************************
 * Вначале выполняется операция перестановки-выбора битов исходного ключа 
 * K, существо которой определяется таблицей, при этом контрольные биты 
 * ключа K в формируемый 56-битовый ключ не переносятся, а биты, используемые 
 * для шифрования, переставляются в соответствии с указанной таблицей, 
 * где PC1(i) означает номер позиции, в которую поступает i-й бит исходного 
 * ключа.
 * +---------------------------------------------------------------
 * ¦PC1(i)¦ 1 ¦ 2 ¦ 3 ¦ 4 ¦ 5 ¦ 6 ¦ 7 ¦ 8 ¦ 9 ¦ 10¦ 11¦ 12¦ 13¦ 14¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  i   ¦ 57¦ 49¦ 41¦ 33¦ 25¦ 17¦ 9 ¦ 1 ¦ 58¦ 50¦ 42¦ 34¦ 26¦ 18¦
 * +---------------------------------------------------------------
 * 
 * +---------------------------------------------------------------
 * ¦PC1(i)¦ 15¦ 16¦ 17¦ 18¦ 19¦ 20¦ 21¦ 22¦ 23¦ 24¦ 25¦ 26¦ 27¦ 28¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  i   ¦ 10¦ 2 ¦ 59¦ 51¦ 43¦ 35¦ 27¦ 19¦ 11¦ 3 ¦ 60¦ 52¦ 44¦ 36¦
 * +---------------------------------------------------------------
 * 
 * +---------------------------------------------------------------
 * ¦PC1(i)¦ 29¦ 30¦ 31¦ 32¦ 33¦ 34¦ 35¦ 36¦ 37¦ 38¦ 39¦ 40¦ 41¦ 42¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦  i   ¦ 63¦ 55¦ 47¦ 39¦ 31¦ 23¦ 15¦ 7 ¦ 62¦ 54¦ 46¦ 38¦ 30¦ 22¦
 * +---------------------------------------------------------------
 * 
 * +--------------------------------------------------------------+
 * ¦PC1(i)¦ 43¦ 44¦ 45¦ 46¦ 47¦ 48¦ 49¦ 50¦ 51¦ 52¦ 53¦ 54¦ 55¦ 56¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦  i   ¦ 14¦ 6 ¦ 61¦ 53¦ 45¦ 37¦ 29¦ 21¦ 13¦ 5 ¦ 28¦ 20¦ 12¦ 4 ¦
 * +--------------------------------------------------------------+
 *****************************************************************************/
ulong64 pc1(ulong64 v)
{
	uchar	p1[] = 
	{
		60, 52, 44, 36, 59, 51, 43, 35, 27, 19, 11,  3, 58, 50,
		42, 34, 26, 18, 10,  2, 57, 49, 41, 33, 25, 17,  9,  1
	};
	uchar	p2[] = 
	{
		28, 20, 12,  4, 61, 53, 45, 37, 29, 21, 13,  5, 62, 54,
		46, 38, 30, 22, 14,  6, 63, 55, 47, 39, 31, 23, 15,  7
	};
	ulong64	r = {0, 0};
	ulong t;
	uchar s;

	for (int i = 27; i >= 0; i--)
	{
		t = v.l;
		s = p1[i];

		if (s > 31)
		{
			t = v.h;
			s -= 32;
		}
		r.l |= ((t >> s) & 1) << i;
	}

	for (int i = 27; i >= 0; i--)
	{
		t = v.l;
		s = p2[i];

		if (s > 31)
		{
			t = v.h;
			s -= 32;
		}
		r.h |= ((t >> s) & 1) << i;
	}
	return r;
}

/****************************************************************************
 * После выполнения перестановки-выбора PC1 полученный 56-битовый вектор 
 * K разбивается на два 28-битовых вектора L0 и R0. Далее в каждом из 16 
 * циклов над 28-битовыми векторами Li-1 и Ri-1 , полученными на предыдущем 
 * цикле, выполняется операция циклического сдвига на LSi позиций влево; 
 * значения LSi приведены в таблице
 * +----------------------------------------------------------------------+
 * ¦   i  ¦ 1 ¦ 2 ¦ 3 ¦ 4 ¦ 5 ¦ 6 ¦ 7 ¦ 8 ¦ 9 ¦ 10¦ 11¦ 12¦ 13¦ 14¦ 15¦ 16¦
 * +------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦  LSi ¦ 1 ¦ 1 ¦ 2 ¦ 2 ¦ 2 ¦ 2 ¦ 2 ¦ 2 ¦ 1 ¦ 2 ¦ 2 ¦ 2 ¦ 2 ¦ 2 ¦ 2 ¦ 1 ¦
 * +----------------------------------------------------------------------+
 ****************************************************************************/

/****************************************************************************
 * Полученные в результате выполнения указанной операции 28-битовые вектора 
 * Li и Ri при помощи конкатенации объединяются в 56-битовый вектор, 
 * который подвергается перестановке-выбору PC2. В результате перестановки 
 * PC2  j-й бит 56-битового вектора поступает в PC2(j)-ую позицию 
 * формируемого 48-битового вектора, который и есть ключ Ki, используемый 
 * при шифровании. Логика перестановки-выбора PC2 определяется таблицей
 * +-------------------------------------------------------------------------
 * ¦ PC2(j) ¦ 1 ¦ 2 ¦ 3 ¦ 4 ¦ 5 ¦ 6 ¦ 7 ¦ 8 ¦ 9 ¦ 10¦ 11¦ 12¦ 13¦ 14¦ 15¦ 16¦
 * +--------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦   j    ¦ 14¦ 17¦ 11¦ 24¦ 1 ¦ 5 ¦ 3 ¦ 28¦ 15¦ 6 ¦ 21¦ 10¦ 23¦ 19¦ 12¦ 4 ¦
 * +-------------------------------------------------------------------------
 * 
 * +-------------------------------------------------------------------------
 * ¦ PC2(j) ¦ 17¦ 18¦ 19¦ 20¦ 21¦ 22¦ 23¦ 24¦ 25¦ 26¦ 27¦ 28¦ 29¦ 30¦ 31¦ 32¦
 * +--------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 * ¦   j    ¦ 26¦ 8 ¦ 16¦ 7 ¦ 27¦ 20¦ 13¦ 2 ¦ 41¦ 52¦ 31¦ 37¦ 47¦ 55¦ 30¦ 40¦
 * +-------------------------------------------------------------------------
 * 
 * +------------------------------------------------------------------------+
 * ¦ PC2(j) ¦ 33¦ 34¦ 35¦ 36¦ 37¦ 38¦ 39¦ 40¦ 41¦ 42¦ 43¦ 44¦ 45¦ 46¦ 47¦ 48¦
 * +--------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---¦
 * ¦   j    ¦ 51¦ 45¦ 33¦ 48¦ 44¦ 49¦ 39¦ 56¦ 34¦ 53¦ 46¦ 42¦ 50¦ 36¦ 29¦ 32¦
 * +------------------------------------------------------------------------+
 ****************************************************************************/
ulong64 pc2(ulong64 v)
{
	uchar p1[] = 
	{
		24, 27, 20,  6, 14, 10,  3, 22,  0, 17,  7, 12, 8,  23, 11,  5, 16, 26,  
		1,  9, 19, 25,  4, 15, 54, 43, 36, 29, 49, 40, 48, 30
	};
	uchar p2[] = { 52, 44, 37, 33, 46, 35, 50, 41, 28, 53, 51, 55, 32, 45, 39, 42 };

	ulong64	r = {0, 0};
	ulong t;
	uchar s;

	for (int i = 31; i >= 0; i--)
	{
		t = v.l;
		s = p1[i];

		if (s > 27)
		{
			t = v.h;
			s -= 28;
		}
		r.l |= ((t >> s) & 1) << i;
	}
	for (int i = 15; i >= 0; i--)
	{
		t = v.l;
		s = p2[i];

		if (s > 27)
		{
			t = v.h;
			s -= 28;
		}
		r.h |= ((t >> s) & 1) << i;
	}
	return r;
}

ulong des_encrypt_ecb(uchar *src, ulong srclen, uchar *dst, ulong64 key)
{
	if (srclen % 8 != 0)
		throw "Length of the source buffer must be multiple of 8!";

	ulong64 keys[16];
	ulong64 block;
	ulong i = 0;

	des_create_keys(key, keys);

	for (; i < srclen; i += 8)
	{
		GET_ULONG_BE(block.h, src, i);
		GET_ULONG_BE(block.l, src, i + 4);

		block = des_encrypt_block(block, keys);

		PUT_ULONG_BE(block.h, dst, i);
		PUT_ULONG_BE(block.l, dst, i + 4);
	}

	return i;
}

ulong des_decrypt_ecb(uchar *src, ulong srclen, uchar *dst, ulong64 key)
{
	if (srclen % 8 != 0)
		throw "Length of the source buffer must be multiple of 8!";

	ulong64 keys[16];
	ulong64 block;
	ulong i = 0;

	des_create_keys(key, keys);

	for (; i < srclen; i += 8)
	{
		GET_ULONG_BE(block.h, src, i);
		GET_ULONG_BE(block.l, src, i + 4);

		block = des_decrypt_block(block, keys);

		PUT_ULONG_BE(block.h, dst, i);
		PUT_ULONG_BE(block.l, dst, i + 4);
	}

	return i;
}

ulong des_encrypt_cbc(uchar *src, ulong srclen, uchar *dst, ulong64 key, ulong64 iv)
{
	if (srclen % 8 != 0)
		throw "Length of the source buffer must be multiple of 8!";

	ulong64 keys[16];
	ulong64 block, vector = iv;
	ulong i = 0;

	des_create_keys(key, keys);

	for (; i < srclen; i += 8)
	{
		GET_ULONG_BE(block.h, src, i);
		GET_ULONG_BE(block.l, src, i + 4);

		block.h ^= vector.h;
		block.l ^= vector.l;

		block = des_encrypt_block(block, keys);

		PUT_ULONG_BE(block.h, dst, i);
		PUT_ULONG_BE(block.l, dst, i + 4);

		vector = block;
	}

	return i;
}

ulong des_decrypt_cbc(uchar *src, ulong srclen, uchar *dst, ulong64 key, ulong64 iv)
{
	if (srclen % 8 != 0)
		throw "Length of the source buffer must be multiple of 8!";

	ulong64 keys[16];
	ulong64 block, result, vector = iv;
	ulong i = 0;

	des_create_keys(key, keys);

	for (; i < srclen; i += 8)
	{
		GET_ULONG_BE(block.h, src, i);
		GET_ULONG_BE(block.l, src, i + 4);

		result = des_decrypt_block(block, keys);

		result.h ^= vector.h;
		result.l ^= vector.l;

		PUT_ULONG_BE(result.h, dst, i);
		PUT_ULONG_BE(result.l, dst, i + 4);

		vector = block;
	}

	return i;
}

ulong des_encrypt_cfb(uchar *src, ulong srclen, uchar *dst, ulong64 key, ulong64 iv, ulong blocklen)
{
	if (blocklen == 0)
		throw "Length of the block must not be 0!";

	if (srclen % blocklen != 0)
		throw "Length of the source buffer must be multiple of blocklen!";

	ulong64 keys[16];
	ULong64 result, vector;
	ulong i = 0;
	
	vector.s = iv;
	des_create_keys(key, keys);

	for (; i < srclen; i += blocklen)
	{
		result.s = des_encrypt_block(vector.s, keys);

		result.v >>= 64 - blocklen;
		result.v ^= get_block_by_offset(src, i, blocklen);

		vector.v <<= blocklen;
		vector.v |= result.v;

		put_block_by_offset(dst, i, result.v, blocklen);
	}

	return i;
}

ulong des_decrypt_cfb(uchar *src, ulong srclen, uchar *dst, ulong64 key, ulong64 iv, ulong blocklen)
{
	if (blocklen == 0)
		throw "Length of the block must not be 0!";

	if (srclen % blocklen != 0)
		throw "Length of the source buffer must be multiple of blocklen!";

	ulong64 keys[16];
	ULong64 result, vector;
	unsigned long long block;
	ulong i = 0;

	vector.s = iv;
	des_create_keys(key, keys);

	for (; i < srclen; i += blocklen)
	{
		result.s = des_encrypt_block(vector.s, keys);

		result.v >>= 64 - blocklen;
		block = get_block_by_offset(src, i, blocklen);

		vector.v <<= blocklen;
		vector.v |= block;

		put_block_by_offset(dst, i, block ^ result.v, blocklen);
	}

	return i;
}

ulong des_encrypt_ofb(uchar *src, ulong srclen, uchar *dst, ulong64 key, ulong64 iv, ulong blocklen)
{
	if (blocklen == 0)
		throw "Length of the block must not be 0!";

	if (srclen % blocklen != 0)
		throw "Length of the source buffer must be multiple of blocklen!";

	ulong64 keys[16];
	ULong64 result, vector;
	ulong i = 0;

	vector.s = iv;
	des_create_keys(key, keys);

	for (; i < srclen; i += blocklen)
	{
		result.s = des_encrypt_block(vector.s, keys);

		result.v >>= 64 - blocklen;

		vector.v <<= blocklen;
		vector.v |= result.v;

		result.v ^= get_block_by_offset(src, i, blocklen);

		put_block_by_offset(dst, i, result.v, blocklen);
	}

	return i;
}

ulong des_decrypt_ofb(uchar *src, ulong srclen, uchar *dst, ulong64 key, ulong64 iv, ulong blocklen)
{
	return des_encrypt_ofb(src, srclen, dst, key, iv, blocklen);
}

unsigned long long get_block_by_offset(uchar *src, ulong offset, ulong blocklen)
{
	unsigned long long block;
	ulong bit;

	block = 0;

	for (ulong i = 0; i < blocklen; i++)
	{
		GET_BIT_BE(bit, src, offset / 8, offset % 8);
		offset++;
		block <<= 1;
		block += bit;
	}

	return block;
}

void put_block_by_offset(uchar *dst, ulong offset, unsigned long long block, ulong blocklen)
{
	offset += blocklen - 1;
	for (ulong i = 0; i < blocklen; i++)
	{
		PUT_BIT_BE(block % 2 == 1, dst, offset / 8, offset % 8);
		offset--;
		block >>= 1;
	}
}